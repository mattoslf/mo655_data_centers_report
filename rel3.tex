\documentclass[12pt,a4paper]{report}
\usepackage[hmargin=2cm,vmargin=3.5cm,bmargin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage[pdftex]{hyperref}
\usepackage{csvsimple}
\usepackage{color}
\usepackage{mathtools}
\usepackage{float}

% Headers and Footers
\usepackage{fancyhdr}

\addto\captionsportuguese{\renewcommand{\chaptername}{}}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keywordstyle=\color{blue},       % keyword style
%  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


%\begin{itemize}
%\item A saída deve estar em ordem crescente (o elemento da saída não pode ser menor do que o seu antecessor de acordo com o critério adotado para ordenação);
%\item A saída é uma permutação (reordenação) da entrada;
%\end{itemize}
    
%\section{Algoritmos $\mathbf{O(n^2)}$}
%\subsection{Bubble Sort}

%\begin{lstlisting}[language=C++]
%\end{lstlisting}

%\begin{figure}[H]
%\includegraphics[width=\textwidth]{Imagens/bubble.png}
%\caption{Bubble Sort para diversos formatos de vetores}
%\end{figure}

%\begin{table}[H]
%\caption{Tabela dos tempos para os vetores de melhores e piores casos}
%\begin{center}
%\begin{tabular}{|c|c|c|c|c|c|}
%\hline 
%Caso & Bubble Sort (us) & Insertion Sort (us) & Merge Sort (us) & Heap Sort (us) & Quick Sort (us) \\ 
%\hline
%Melhor & 0,86  & 0,84 & 8,49 & 1,99 & 2,61 \\
%\hline 
%Pior & 24,97 & 24,56 & 8,97 & 7,73 & 15,8 \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}


% Headers and Footers
\pagestyle{fancy} % fancy style
\lhead{\rightmark} % left header
\rhead{\leftmark} % right header
\lfoot{} % left footer
\cfoot{\textbf{\thepage}} % central footer
\rfoot{} % right footer
% Headers and Footers

\makeindex

% define the title
\author{Leandro Souza da  Silva - RA: 191082 \\ Luís Felipe Mattos - RA: 107822}
\title{MO655 - Comunicação em Datacenters}
%\date{}
\begin{document}

% generates the title
\maketitle

% insert the table of contents
\tableofcontents

\chapter{Introdução}

Com o crescimento da demanda dos usuários por poder computacional e armazenamento, cada vez mais as grandes empresas estão investindo em estruturas próprias de datacenters. Esta estrutura inclui tanto os computadores em si, os discos de armazenamento e os racks como também inclui a própria sala que ficarão estes racks. Estas salas devem tem uma arquitetura própria, como por exemplo, o piso elevado, sistema de refrigeração e circulação de ar. Um exemplo por ser visto na figura \ref{dc_overview}.\\

\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/datacenter.png}
\caption{Visão geral de um Datacenter}
\label{dc_overview}
\end{figure}

Além da estrutura física, a parte computacional, principalmente relacionada à comunicação interna e externa do datacenter possui alguns requisitos básicos para que possa oferecer um serviço de qualidade para os usuários. Estes requisitos são citados a seguir:\\

\begin{itemize}
\item Escalabilidade
\item Tolerância a Falhas
\item Latêcia
\item Capacidade da Rede
\item Virtualização
\end{itemize}

A seguir, os requisitos citados serão mais detalhados.\\

\section{Requisitos de Rede}

\subsection{Escalabilidade}
O sistema deve ser construido de tal forma que seja possível haver uma expansão, caso a demanda aumente. Este requisito diz respeito tanto ao hardware como ao software. Para o hardware, a estrutura das máquinas deve permitir que o sistema seja melhorado e também deve haver espaço físico para a inclusão de novas máquinas. Atualmente, existem alguns sistemas modulares que possuem uma fácil integração de novos módulos.\\

Um exemplo é a utilização de datacenters em containers, cada container possui um sistema completo com refrigeração própria e é facilmente transportado. Com isso, pode-se expandir facilmente uma estrutura de um datacenter. Um exemplo de container pode ser visto na figura \ref{dc_container}.\\

\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/container_dc.jpg}
\caption{Datacenter em container}
\label{dc_container}
\end{figure}

\subsection{Tolerância a Falhas}
O sistema deve ser capaz de prevenir e corrigir falhas. Por causa disso, a maioria dos sistemas de datacenters possuem redundâncias em quase todos aspectos do datacenter. Existem backups dos dados dos usuários, a comunicação interna é feita de modo que existam vários caminhos possíveis da fonte para o destino e além disso, alguns datacenters possuem backups em outros datacenters. Apesar disso, existe o custo de manter estas cópias atualizadas.\\

Mais a frente falaremos um pouco mais sobre as redundâncias dos caminhos de comunicação interna dos datacenters, tanto relacionados à topologia como relacionado aos protocolos de comunicação e roteamento.\\

\subsection{Latêcia}
Um dos principais desafios dos datacenters é possuir baixa latência, assim, a performance do sistema como um todo se mantém em um nível aceitável pelos usuários. Para isso, a topologia é muito importante, uma vez que quanto menor o caminho entre a fonte e o destino, menor a latência. Porém, outro fator que influencia muito a latência é o nível de congestionamento da rede, mais a frente iremos tratar sobre os protocolos e como estes controlam o nível de congestionamento da rede.\\

\subsection{Capacidade da Rede}


\subsection{Virtualização}


\chapter{Motivação}

\chapter{Topologias}

\chapter{Protocolos}

\section{Roteamento}

Embora a maioria dos esquemas básicos de roteamento busquem rotas entre
dois servidores com latência curta, um encaminhamento mais sofisticado exige maior
consideração e otimização da latência, confiabilidade, throughput, energia e etc. Esse tipo
de otimização é conhecido como problema de Traffic Engineering (TE).

Existem poucos mecanismos para a otimização de roteamento Data Center Network (DCN)
hoje em dia. Essa seção apresenta três diferentes esquemas de roteamento, ECMP, VL2 e DRAD.

\subsection{Equal Cost Multipath (ECMP)}

  Em um ambiente como datacenters, onde topologias como Fat-Tree, Clos proporcionam múltiplos caminhos,  
  o ECMP é utilizado com intuíto de balancear a carga, dividindo a quantidade de pacotes ou fluxos ao
  longo da topologia pelos seus múltiplos caminhos existentes. 
  O ECMP possui dois modos de operação:


  \begin{enumerate}
    \item  \textbf{Balanceamento baseado em fluxo}\\  
      Utiliza o hash na tupla de 5 campos de cada
      pacote e o encaminha para uma interface de saída. Todos os pacotes do mesmo
      fluxo TCP/IP serão encaminhados pela mesma interface. Este é o modo padrão de
      funcionamento do ECMP.

    \item \textbf{Balanceamento baseado em pacote}\\
      Utiliza o modelo round robin para cada pa-
      cote, fazendo com que pacotes do mesmo fluxo sigam por rotas diferentes.

  \end{enumerate}

  A diferença básica destes dois modos de operação do ECMP impacta diretamente
  nos protocolos, tais como TCP ou MPTCP. Quando utiliza-se o modo de balanceamento
  baseado em pacote, pacotes que pertencem ao mesmo fluxo TCP/IP são roteados por
  rotas diferentes o que pode causar reordenação nos hosts finais e consequentemente di-
  minuir a taxa de transferência. 

  Quando o balanceamento baseado em fluxos é utilizado, o problema da entrega desordenada
  não ocorre pois todos os pacotes de um mesmo fluxo TCP/IP seguem a mesma rota.
  O ECMP, mesmo usando o modelo baseado em fluxo que normalmente se apresenta como 
  melhor solução, ainda sofre com as colisões que ocorrem
  um vez que soluções baseadas em hashing estatisticamente podem gerar as mesmas saídas
  quando aplicadas em diferentes entradas. 
  
  No caso da utilização do ECMP para balancear fluxos MPTCP, isso pode significar 
  alocar os subfluxos de uma mesma conexão MPTCP em uma mesma rota.

\subsection{VL2}

  É outro mecanismo de seleção de caminhos distribuídos. Diferente do ECMP,
  ele coloca a lógica de seleção nos swithces da borda. Em VL2, um swithc da borda
  encaminha primeiro um fluxo a um swithc do núcleo, selecionado aleatoriamente, que
  então encaminha o fluxo para o destino. Como resultado, múltiplos fluxos
  ainda pode colidir na mesma porta de saída como ECMP.

\subsection{Distributed Adaptive Routing for Datacenter Networks (DRAD)}

Difere do ECMP e VL2 em dois aspectos. Primeiro, seu algoritmo de seleção de caminho é
sensível à carga. Se vários fluxos colidem no mesmo caminho, o algoritmo deslocará os fluxos do caminho colidido
para os caminhos mais ligeiramente carregados. Em segundo lugar, coloca a lógica de seleção de
caminhos em sistemas finais, em vez de em switches, para facilitar a implantação. 

Um módulo de seleção de caminho que executa em um sistema de extremidade monitora
o estado do caminho e comuta-o de acordo com a carga. 
Uma DCN pode implantar o DARD atualizando a pilha de software do seu sistema final em vez de atualizar switches.

\chapter{Tendências}

\section{Facebook Fabric}






Para a próxima geração de projeto de rede de data center, O Facebook se desafiou a fazer todo o data center construindo uma rede de alto desempenho, em vez de um sistema hierarquicamente super-assinado (oversubscription) de clusters. 
O Facebook Também queria um caminho claro e fácil para a rápida implantação de rede e escalabilidade de desempenho sem perder as
infraestruturas maciças já construídas, sempre que precisasse de mais capacidade.

\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/datacenter_facebook.jpg}
\caption{Data Center do Facebook em Altoona Pennsylvania - EUA}
\label{dc_container}
\end{figure}

Para conseguir isso, foi utilizada uma abordagem desagregada: 
em vez dos grandes dispositivos e clusters, 
a rede foi quebrada em pequenas unidades idênticas, 
pods de servidor, e foi conectividade uniforme de alto desempenho entre todos os pods do data center.


Cada pod é servido por um conjunto de quatro dispositivos que são chamados de fabric switches, utilizando a arquitetura de 4-postos 3 + 1 para 
uplinks TOR de rack de servidor e escalável além disso, se necessário. Cada TOR tem  4 x 40G uplinks, 
fornecendo 160G de capacidade total de largura de banda para um rack de servidores conectados a 10G.

\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/pod.jpg}
\caption{Um pod simples - nova unidade de rede do Facebook Fabric}
\label{dc_container}
\end{figure}


O que difere das arquitetura anteriores é que cada pod tem apenas 48 racks de servidor, 
e este fator é sempre o mesmo para todos os pods. 
É um bloco de construção eficiente que se encaixa bem em várias plantas de centro de dados,
e requer apenas switches básicos de tamanho médio para agregar os TORs. 
A menor densidade de portas dos fabrice switches torna essa arquitetura interna muito simples, 
modular e robusta, e há várias opções de fácil acesso disponíveis em várias fontes.


\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/scheme_fabric.jpg}
\caption{Esquemático da topologia do Fabric Data Center}
\label{dc_container}
\end{figure}


Este design altamente modular permite dimensionar rapidamente a capacidade em qualquer dimensão, 
dentro de uma estrutura simples e uniforme.


O Fabric foi construido usando padrão BGP4 como o único protocolo de roteamento. 
Para manter as coisas simples, foi usado apenas os recursos mínimos de protocolo necessários. 
Isso nos permitiu aproveitar o desempenho e a escalabilidade de um plano de controle distribuído para convergência, 
oferecendo gerenciamento de propagação de roteamento rígido e granular e garantindo compatibilidade com uma ampla 
gama de sistemas e software existentes. Ao mesmo tempo, foi desenvolvido um controlador BGP centralizado que é capaz de 
substituir quaisquer caminhos de roteamento no fabric por decisões de software puro. 




\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{imagens/phisic_fabric.jpg}
\caption{Esquemático otimizado da topologia física do Fabric Data Center}
\label{dc_container}
\end{figure}


Apesar da grande escala de centenas de milhares de fios de fibra, a infraestrutura física 
e de cabeamento é muito menos complexo do que pode parecer nos desenhos de topologia de rede lógica. 
Os projetos de construção do Fabric foram otimizados, para encurtar comprimentos de cabeamento 
e permitir uma rápida implantação. Altoona foi a primeira implementação deste novo tipo de layout.




\chapter{Conclusão}

\chapter{Referências}

\begin{itemize}
\item Manual de referência do NS-3 \begin{verbatim}https://www.nsnam.org/docs/release/3.8/manual.pdf\end{verbatim}
\item Documentação \begin{verbatim}https://www.nsnam.org/doxygen/index.html\end{verbatim}
\end{itemize}

\end{document}
